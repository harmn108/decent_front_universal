'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var dagPB = require('ipld-dag-pb');
var DAGNode = dagPB.DAGNode;
var DAGLink = dagPB.DAGLink;
var promisify = require('promisify-es6');
var bs58 = require('bs58');
var streamToValue = require('../stream-to-value');
var cleanMultihash = require('../clean-multihash');
var LRU = require('lru-cache');
var lruOptions = {
  max: 128
};
var Unixfs = require('ipfs-unixfs');
var cache = LRU(lruOptions);

module.exports = function (send) {
  var api = {
    get: promisify(function (multihash, options, callback) {
      if (typeof options === 'function') {
        callback = options;
        options = {};
      }

      if (!options) {
        options = {};
      }

      try {
        multihash = cleanMultihash(multihash, options);
      } catch (err) {
        return callback(err);
      }

      var node = cache.get(multihash);

      if (node) {
        return callback(null, node);
      }

      send({
        path: 'object/get',
        args: multihash
      }, function (err, result) {
        if (err) {
          return callback(err);
        }

        var links = result.Links.map(function (l) {
          return new DAGLink(l.Name, l.Size, new Buffer(bs58.decode(l.Hash)));
        });

        DAGNode.create(result.Data, links, function (err, node) {
          if (err) {
            return callback(err);
          }
          cache.set(multihash, node);
          callback(null, node);
        });
      });
    }),

    put: promisify(function (obj, options, callback) {
      if (typeof options === 'function') {
        callback = options;
        options = {};
      }
      if (!options) {
        options = {};
      }

      var tmpObj = {
        Data: null,
        Links: []
      };

      if (Buffer.isBuffer(obj)) {
        if (!options.enc) {
          tmpObj = {
            Data: obj.toString(),
            Links: []
          };
        }
      } else if (obj.multihash) {
        tmpObj = {
          Data: obj.data.toString(),
          Links: obj.links.map(function (l) {
            var link = l.toJSON();
            link.hash = link.multihash;
            return link;
          })
        };
      } else if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
        tmpObj.Data = obj.Data.toString();
        tmpObj.Links = obj.Links;
      } else {
        return callback(new Error('obj not recognized'));
      }

      var buf = void 0;
      if (Buffer.isBuffer(obj) && options.enc) {
        buf = obj;
      } else {
        buf = new Buffer(JSON.stringify(tmpObj));
      }
      var enc = options.enc || 'json';

      send({
        path: 'object/put',
        qs: { inputenc: enc },
        files: buf
      }, function (err, result) {
        if (err) {
          return callback(err);
        }

        if (Buffer.isBuffer(obj)) {
          if (!options.enc) {
            obj = { Data: obj, Links: [] };
          } else if (options.enc === 'json') {
            obj = JSON.parse(obj.toString());
          }
        }

        var node = void 0;

        if (obj.multihash) {
          node = obj;
        } else if (options.enc === 'protobuf') {
          dagPB.util.deserialize(obj, function (err, _node) {
            if (err) {
              return callback(err);
            }
            node = _node;
            next();
          });
          return;
        } else {
          DAGNode.create(new Buffer(obj.Data), obj.Links, function (err, _node) {
            if (err) {
              return callback(err);
            }
            node = _node;
            next();
          });
          return;
        }
        next();

        function next() {
          var nodeJSON = node.toJSON();
          if (nodeJSON.multihash !== result.Hash) {
            var _err = new Error('multihashes do not match');
            return callback(_err);
          }

          cache.set(result.Hash, node);
          callback(null, node);
        }
      });
    }),
    data: promisify(function (multihash, options, callback) {
      if (typeof options === 'function') {
        callback = options;
        options = {};
      }
      if (!options) {
        options = {};
      }

      try {
        multihash = cleanMultihash(multihash, options);
      } catch (err) {
        return callback(err);
      }

      var node = cache.get(multihash);

      if (node) {
        return callback(null, node.data);
      }

      send({
        path: 'object/data',
        args: multihash
      }, function (err, result) {
        if (err) {
          return callback(err);
        }

        if (typeof result.pipe === 'function') {
          streamToValue(result, callback);
        } else {
          callback(null, result);
        }
      });
    }),
    links: promisify(function (multihash, options, callback) {
      if (typeof options === 'function') {
        callback = options;
        options = {};
      }
      if (!options) {
        options = {};
      }

      try {
        multihash = cleanMultihash(multihash, options);
      } catch (err) {
        return callback(err);
      }

      var node = cache.get(multihash);

      if (node) {
        return callback(null, node.links);
      }

      send({
        path: 'object/links',
        args: multihash
      }, function (err, result) {
        if (err) {
          return callback(err);
        }

        var links = [];

        if (result.Links) {
          links = result.Links.map(function (l) {
            return new DAGLink(l.Name, l.Size, new Buffer(bs58.decode(l.Hash)));
          });
        }
        callback(null, links);
      });
    }),
    stat: promisify(function (multihash, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }
      if (!opts) {
        opts = {};
      }

      try {
        multihash = cleanMultihash(multihash, opts);
      } catch (err) {
        return callback(err);
      }

      send({
        path: 'object/stat',
        args: multihash
      }, callback);
    }),
    new: promisify(function (template, callback) {
      if (typeof template === 'function') {
        callback = template;
        template = undefined;
      }
      send({
        path: 'object/new',
        args: template
      }, function (err, result) {
        if (err) {
          return callback(err);
        }

        var data = void 0;

        if (template) {
          if (template !== 'unixfs-dir') {
            return callback(new Error('unkown template: ' + template));
          }
          data = new Unixfs('directory').marshal();
        } else {
          data = new Buffer(0);
        }

        DAGNode.create(data, function (err, node) {
          if (err) {
            return callback(err);
          }

          if (node.toJSON().multihash !== result.Hash) {
            console.log(node.toJSON());
            console.log(result);
            return callback(new Error('multihashes do not match'));
          }

          callback(null, node);
        });
      });
    }),
    patch: {
      addLink: promisify(function (multihash, dLink, opts, callback) {
        if (typeof opts === 'function') {
          callback = opts;
          opts = {};
        }
        if (!opts) {
          opts = {};
        }

        try {
          multihash = cleanMultihash(multihash, opts);
        } catch (err) {
          return callback(err);
        }

        send({
          path: 'object/patch/add-link',
          args: [multihash, dLink.name, bs58.encode(dLink.multihash).toString()]
        }, function (err, result) {
          if (err) {
            return callback(err);
          }
          api.get(result.Hash, { enc: 'base58' }, callback);
        });
      }),
      rmLink: promisify(function (multihash, dLink, opts, callback) {
        if (typeof opts === 'function') {
          callback = opts;
          opts = {};
        }
        if (!opts) {
          opts = {};
        }

        try {
          multihash = cleanMultihash(multihash, opts);
        } catch (err) {
          return callback(err);
        }

        send({
          path: 'object/patch/rm-link',
          args: [multihash, dLink.name]
        }, function (err, result) {
          if (err) {
            return callback(err);
          }
          api.get(result.Hash, { enc: 'base58' }, callback);
        });
      }),
      setData: promisify(function (multihash, data, opts, callback) {
        if (typeof opts === 'function') {
          callback = opts;
          opts = {};
        }
        if (!opts) {
          opts = {};
        }

        try {
          multihash = cleanMultihash(multihash, opts);
        } catch (err) {
          return callback(err);
        }

        send({
          path: 'object/patch/set-data',
          args: [multihash],
          files: data
        }, function (err, result) {
          if (err) {
            return callback(err);
          }
          api.get(result.Hash, { enc: 'base58' }, callback);
        });
      }),
      appendData: promisify(function (multihash, data, opts, callback) {
        if (typeof opts === 'function') {
          callback = opts;
          opts = {};
        }
        if (!opts) {
          opts = {};
        }

        try {
          multihash = cleanMultihash(multihash, opts);
        } catch (err) {
          return callback(err);
        }

        send({
          path: 'object/patch/append-data',
          args: [multihash],
          files: data
        }, function (err, result) {
          if (err) {
            return callback(err);
          }
          api.get(result.Hash, { enc: 'base58' }, callback);
        });
      })
    }
  };

  return api;
};