'use strict';

var promisify = require('promisify-es6');
var EventEmitter = require('events');
var eos = require('end-of-stream');
var isNode = require('detect-node');
var PubsubMessageStream = require('../pubsub-message-stream');
var stringlistToArray = require('../stringlist-to-array');

var NotSupportedError = function NotSupportedError() {
  return new Error('pubsub is currently not supported when run in the browser');
};

/* Public API */
module.exports = function (send) {
  /* Internal subscriptions state and functions */
  var ps = new EventEmitter();
  var subscriptions = {};
  ps.id = Math.random();
  return {
    subscribe: function subscribe(topic, options, handler, callback) {
      var defaultOptions = {
        discover: false
      };

      if (typeof options === 'function') {
        callback = handler;
        handler = options;
        options = defaultOptions;
      }

      if (!options) {
        options = defaultOptions;
      }

      // Throw an error if ran in the browsers
      if (!isNode) {
        if (!callback) {
          return Promise.reject(NotSupportedError());
        }
        return callback(NotSupportedError());
      }

      // promisify doesn't work as we always pass a
      // function as last argument (`handler`)
      if (!callback) {
        return new Promise(function (resolve, reject) {
          _subscribe(topic, options, handler, function (err) {
            if (err) {
              return reject(err);
            }
            resolve();
          });
        });
      }

      _subscribe(topic, options, handler, callback);
    },
    unsubscribe: function unsubscribe(topic, handler) {
      if (!isNode) {
        throw NotSupportedError();
      }

      if (ps.listenerCount(topic) === 0 || !subscriptions[topic]) {
        throw new Error('Not subscribed to \'' + topic + '\'');
      }

      ps.removeListener(topic, handler);

      // Drop the request once we are actualy done
      if (ps.listenerCount(topic) === 0) {
        subscriptions[topic].abort();
        subscriptions[topic] = null;
      }
    },
    publish: promisify(function (topic, data, callback) {
      if (!isNode) {
        return callback(NotSupportedError());
      }

      if (!Buffer.isBuffer(data)) {
        return callback(new Error('data must be a Buffer'));
      }

      var request = {
        path: 'pubsub/pub',
        args: [topic, data]
      };

      send(request, callback);
    }),
    ls: promisify(function (callback) {
      if (!isNode) {
        return callback(NotSupportedError());
      }

      var request = {
        path: 'pubsub/ls'
      };

      send.andTransform(request, stringlistToArray, callback);
    }),
    peers: promisify(function (topic, callback) {
      if (!isNode) {
        return callback(NotSupportedError());
      }

      var request = {
        path: 'pubsub/peers',
        args: [topic]
      };

      send.andTransform(request, stringlistToArray, callback);
    }),
    setMaxListeners: function setMaxListeners(n) {
      return ps.setMaxListeners(n);
    }
  };

  function _subscribe(topic, options, handler, callback) {
    ps.on(topic, handler);
    if (subscriptions[topic]) {
      return callback();
    }

    // Request params
    var request = {
      path: 'pubsub/sub',
      args: [topic],
      qs: {
        discover: options.discover
      }

      // Start the request and transform the response
      // stream to Pubsub messages stream
    };subscriptions[topic] = send.andTransform(request, PubsubMessageStream.from, function (err, stream) {
      if (err) {
        subscriptions[topic] = null;
        ps.removeListener(topic, handler);
        return callback(err);
      }

      stream.on('data', function (msg) {
        ps.emit(topic, msg);
      });

      stream.on('error', function (err) {
        ps.emit('error', err);
      });

      eos(stream, function (err) {
        if (err) {
          ps.emit('error', err);
        }

        subscriptions[topic] = null;
        ps.removeListener(topic, handler);
      });

      callback();
    });
  }
};