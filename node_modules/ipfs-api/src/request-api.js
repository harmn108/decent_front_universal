'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var Qs = require('qs');
var qsDefaultEncoder = require('qs/lib/utils').encode;
var isNode = require('detect-node');
var ndjson = require('ndjson');
var pump = require('pump');
var once = require('once');
var getFilesStream = require('./get-files-stream');
var streamToValue = require('./stream-to-value');
var streamToJsonValue = require('./stream-to-json-value');
var request = require('./request');

// -- Internal

function parseError(res, cb) {
  var error = new Error('Server responded with ' + res.statusCode);
  streamToJsonValue(res, function (err, payload) {
    if (err) {
      return cb(err);
    }

    if (payload) {
      error.code = payload.Code;
      error.message = payload.Message || payload.toString();
    }
    cb(error);
  });
}

function onRes(buffer, cb) {
  return function (res) {
    var stream = Boolean(res.headers['x-stream-output']);
    var chunkedObjects = Boolean(res.headers['x-chunked-output']);
    var isJson = res.headers['content-type'] && res.headers['content-type'].indexOf('application/json') === 0;

    if (res.statusCode >= 400 || !res.statusCode) {
      return parseError(res, cb);
    }

    // Return the response stream directly
    if (stream && !buffer) {
      return cb(null, res);
    }

    // Return a stream of JSON objects
    if (chunkedObjects && isJson) {
      var outputStream = pump(res, ndjson.parse());
      return cb(null, outputStream);
    }

    // Return a JSON object
    if (isJson) {
      return streamToJsonValue(res, cb);
    }

    // Return a value
    return streamToValue(res, cb);
  };
}

function requestAPI(config, options, callback) {
  options.qs = options.qs || {};
  callback = once(callback);

  if (Array.isArray(options.files)) {
    options.qs.recursive = true;
  }

  if (Array.isArray(options.path)) {
    options.path = options.path.join('/');
  }
  if (options.args && !Array.isArray(options.args)) {
    options.args = [options.args];
  }
  if (options.args) {
    options.qs.arg = options.args;
  }
  if (options.files && !Array.isArray(options.files)) {
    options.files = [options.files];
  }

  if (options.qs.r) {
    options.qs.recursive = options.qs.r;
    // From IPFS 0.4.0, it throws an error when both r and recursive are passed
    delete options.qs.r;
  }

  options.qs['stream-channels'] = true;

  var stream = void 0;
  if (options.files) {
    stream = getFilesStream(options.files, options.qs);
  }

  // this option is only used internally, not passed to daemon
  delete options.qs.followSymlinks;

  var method = 'POST';
  var headers = {};

  if (isNode) {
    // Browsers do not allow you to modify the user agent
    headers['User-Agent'] = config['user-agent'];
  }

  if (options.files) {
    if (!stream.boundary) {
      return callback(new Error('No boundary in multipart stream'));
    }

    headers['Content-Type'] = 'multipart/form-data; boundary=' + stream.boundary;
  }

  var qs = Qs.stringify(options.qs, {
    arrayFormat: 'repeat',
    encoder: function encoder(data) {
      // TODO: future releases of qs will provide the default
      // encoder as a 2nd argument to this function; it will
      // no longer be necessary to import qsDefaultEncoder
      if (Buffer.isBuffer(data)) {
        var uriEncoded = '';
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var byte = _step.value;

            // https://tools.ietf.org/html/rfc3986#page-14
            // ALPHA (%41-%5A and %61-%7A), DIGIT (%30-%39), hyphen (%2D), period (%2E), underscore (%5F), or tilde (%7E)
            if (byte >= 0x41 && byte <= 0x5A || byte >= 0x61 && byte <= 0x7A || byte >= 0x30 && byte <= 0x39 || byte === 0x2D || byte === 0x2E || byte === 0x5F || byte === 0x7E) {
              uriEncoded += String.fromCharCode(byte);
            } else {
              var hex = byte.toString(16);
              // String.prototype.padStart() not widely supported yet
              var padded = hex.length === 1 ? '0' + hex : hex;
              uriEncoded += '%' + padded;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return uriEncoded;
      }
      return qsDefaultEncoder(data);
    }
  });
  var req = request(config.protocol)({
    hostname: config.host,
    path: '' + config['api-path'] + options.path + '?' + qs,
    port: config.port,
    method: method,
    headers: headers
  }, onRes(options.buffer, callback));

  req.on('error', function (err) {
    callback(err);
  });

  if (options.files) {
    stream.pipe(req);
  } else {
    req.end();
  }

  return req;
}

//
// -- Module Interface

exports = module.exports = function (config) {
  /*
   * options: {
   *   path:   // API path (like /add or /config) - type: string
   *   args:   // Arguments to the command - type: object
   *   qs:     // Opts as query string opts to the command --something - type: object
   *   files:  // files to be sent - type: string, buffer or array of strings or buffers
   *   buffer: // buffer the request before sending it - type: bool
   * }
   */
  var send = function send(options, callback) {
    if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object') {
      return callback(new Error('no options were passed'));
    }

    return requestAPI(config, options, callback);
  };

  // Send a HTTP request and pass via a transform function
  // to convert the response data to wanted format before
  // returning it to the callback.
  // Eg. send.andTransform({}, (e) => JSON.parse(e), (err, res) => ...)
  send.andTransform = function (options, transform, callback) {
    return send(options, function (err, res) {
      if (err) {
        return callback(err);
      }
      transform(res, callback);
    });
  };

  return send;
};