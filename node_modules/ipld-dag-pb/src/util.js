'use strict';

var CID = require('cids');
var protobuf = require('protocol-buffers');
var proto = protobuf(require('./dag.proto'));
var DAGLink = require('./dag-link');
var DAGNode = require('./dag-node');

exports = module.exports;

function cid(node, callback) {
  if (node.multihash) {
    return callback(null, new CID(node.multihash));
  }
  callback(new Error('not valid dagPB node'));
}

function serialize(node, callback) {
  var serialized = void 0;

  try {
    var pb = toProtoBuf(node);
    serialized = proto.PBNode.encode(pb);
  } catch (err) {
    return callback(err);
  }

  callback(null, serialized);
}

function deserialize(data, callback) {
  var pbn = proto.PBNode.decode(data);

  var links = pbn.Links.map(function (link) {
    return new DAGLink(link.Name, link.Tsize, link.Hash);
  });

  var buf = pbn.Data || new Buffer(0);

  DAGNode.create(buf, links, callback);
}

function toProtoBuf(node) {
  var pbn = {};

  if (node.data && node.data.length > 0) {
    pbn.Data = node.data;
  } else {
    // NOTE: this has to be null in order to match go-ipfs serialization `null !== new Buffer(0)`
    pbn.Data = null;
  }

  if (node.links && node.links.length > 0) {
    pbn.Links = node.links.map(function (link) {
      return {
        Hash: link.multihash,
        Name: link.name,
        Tsize: link.size
      };
    });
  } else {
    pbn.Links = null;
  }

  return pbn;
}

exports.serialize = serialize;
exports.deserialize = deserialize;
exports.cid = cid;