/*
 * Id is an object representation of a peer Id. a peer Id is a multihash
 */

'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var mh = require('multihashes');
var crypto = require('libp2p-crypto');
var assert = require('assert');
var waterfall = require('async/waterfall');

var PeerId = function () {
  function PeerId(id, privKey, pubKey) {
    _classCallCheck(this, PeerId);

    assert(Buffer.isBuffer(id), 'invalid id provided');

    if (privKey && pubKey) {
      assert(privKey.public.bytes.equals(pubKey.bytes), 'inconsistent arguments');
    }

    this._id = id;
    this._idB58String = mh.toB58String(this.id);
    this._privKey = privKey;
    this._pubKey = pubKey;
  }

  _createClass(PeerId, [{
    key: 'marshalPubKey',


    // Return the protobuf version of the public key, matching go ipfs formatting
    value: function marshalPubKey() {
      if (this.pubKey) {
        return crypto.marshalPublicKey(this.pubKey);
      }
    }

    // Return the protobuf version of the private key, matching go ipfs formatting

  }, {
    key: 'marshalPrivKey',
    value: function marshalPrivKey() {
      if (this.privKey) {
        return crypto.marshalPrivateKey(this.privKey);
      }
    }

    // pretty print

  }, {
    key: 'toPrint',
    value: function toPrint() {
      return this.toJSON();
    }

    // return the jsonified version of the key, matching the formatting
    // of go-ipfs for its config file

  }, {
    key: 'toJSON',
    value: function toJSON() {
      return {
        id: this.toB58String(),
        privKey: toB64Opt(this.marshalPrivKey()),
        pubKey: toB64Opt(this.marshalPubKey())
      };
    }

    // encode/decode functions

  }, {
    key: 'toHexString',
    value: function toHexString() {
      return mh.toHexString(this.id);
    }
  }, {
    key: 'toBytes',
    value: function toBytes() {
      return this.id;
    }
  }, {
    key: 'toB58String',
    value: function toB58String() {
      return this._idB58String;
    }
  }, {
    key: 'isEqual',
    value: function isEqual(id) {
      if (Buffer.isBuffer(id)) {
        return this.id.equals(id);
      } else if (id.id) {
        return this.id.equals(id.id);
      } else {
        throw new Error('not valid Id');
      }
    }

    /*
     * Check if this PeerId instance is valid (privKey -> pubKey -> Id)
     */

  }, {
    key: 'isValid',
    value: function isValid(callback) {
      // TODO Needs better checking
      if (this.privKey && this.privKey.public && this.privKey.public.bytes && Buffer.isBuffer(this.pubKey.bytes) && this.privKey.public.bytes.equals(this.pubKey.bytes)) {
        callback();
      } else {
        callback(new Error('Keys not match'));
      }
    }
  }, {
    key: 'id',
    get: function get() {
      return this._id;
    },
    set: function set(val) {
      throw new Error('Id is immutable');
    }
  }, {
    key: 'privKey',
    get: function get() {
      return this._privKey;
    },
    set: function set(privKey) {
      this._privKey = privKey;
    }
  }, {
    key: 'pubKey',
    get: function get() {
      if (this._pubKey) {
        return this._pubKey;
      }

      if (this._privKey) {
        return this._privKey.public;
      }
    },
    set: function set(pubKey) {
      this._pubKey = pubKey;
    }
  }]);

  return PeerId;
}();

exports = module.exports = PeerId;

// generation
exports.create = function (opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  opts = opts || {};
  opts.bits = opts.bits || 2048;

  waterfall([function (cb) {
    return crypto.generateKeyPair('RSA', opts.bits, cb);
  }, function (privKey, cb) {
    return privKey.public.hash(function (err, digest) {
      cb(err, digest, privKey);
    });
  }], function (err, digest, privKey) {
    if (err) {
      return callback(err);
    }

    callback(null, new PeerId(digest, privKey));
  });
};

exports.createFromHexString = function (str) {
  return new PeerId(mh.fromHexString(str));
};

exports.createFromBytes = function (buf) {
  return new PeerId(buf);
};

exports.createFromB58String = function (str) {
  return new PeerId(mh.fromB58String(str));
};

// Public Key input will be a buffer
exports.createFromPubKey = function (key, callback) {
  if (typeof callback !== 'function') {
    throw new Error('callback is required');
  }

  var buf = key;
  if (typeof buf === 'string') {
    buf = new Buffer(key, 'base64');
  }

  var pubKey = crypto.unmarshalPublicKey(buf);

  pubKey.hash(function (err, digest) {
    if (err) {
      return callback(err);
    }

    callback(null, new PeerId(digest, null, pubKey));
  });
};

// Private key input will be a string
exports.createFromPrivKey = function (key, callback) {
  var buf = key;
  if (typeof buf === 'string') {
    buf = new Buffer(key, 'base64');
  }

  if (typeof callback !== 'function') {
    throw new Error('callback is required');
  }

  waterfall([function (cb) {
    return crypto.unmarshalPrivateKey(buf, cb);
  }, function (privKey, cb) {
    return privKey.public.hash(function (err, digest) {
      cb(err, digest, privKey);
    });
  }], function (err, digest, privKey) {
    if (err) {
      return callback(err);
    }

    callback(null, new PeerId(digest, privKey));
  });
};

exports.createFromJSON = function (obj, callback) {
  if (typeof callback !== 'function') {
    throw new Error('callback is required');
  }

  var id = mh.fromB58String(obj.id);
  var rawPrivKey = obj.privKey && new Buffer(obj.privKey, 'base64');
  var rawPubKey = obj.pubKey && new Buffer(obj.pubKey, 'base64');
  var pub = rawPubKey && crypto.unmarshalPublicKey(rawPubKey);

  if (rawPrivKey) {
    waterfall([function (cb) {
      return crypto.unmarshalPrivateKey(rawPrivKey, cb);
    }, function (priv, cb) {
      return priv.public.hash(function (err, digest) {
        cb(err, digest, priv);
      });
    }, function (privDigest, priv, cb) {
      if (pub) {
        pub.hash(function (err, pubDigest) {
          cb(err, privDigest, priv, pubDigest);
        });
      } else {
        cb(null, privDigest, priv);
      }
    }], function (err, privDigest, priv, pubDigest) {
      if (err) {
        return callback(err);
      }

      if (pub && !privDigest.equals(pubDigest)) {
        return callback(new Error('Public and private key do not match'));
      }

      if (id && !privDigest.equals(id)) {
        return callback(new Error('Id and private key do not match'));
      }

      callback(null, new PeerId(id, priv, pub));
    });
  } else {
    callback(null, new PeerId(id, null, pub));
  }
};

exports.isPeerId = function (peerId) {
  return Boolean((typeof peerId === 'undefined' ? 'undefined' : _typeof(peerId)) === 'object' && peerId._id && peerId._idB58String);
};

function toB64Opt(val) {
  if (val) {
    return val.toString('base64');
  }
}