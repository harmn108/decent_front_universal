'use strict';

var secp256k1 = require('secp256k1');
var multihashing = require('multihashing-async');
var setImmediate = require('async/setImmediate');
var randomBytes = require('libp2p-crypto').randomBytes;

var HASH_ALGORITHM = 'sha2-256';

exports.privateKeyLength = 32;

exports.generateKey = function (callback) {
  var done = function done(err, res) {
    return setImmediate(function () {
      callback(err, res);
    });
  };

  var privateKey = void 0;
  do {
    privateKey = randomBytes(32);
  } while (!secp256k1.privateKeyVerify(privateKey));

  done(null, privateKey);
};

exports.hashAndSign = function (key, msg, callback) {
  var done = function done(err, res) {
    return setImmediate(function () {
      callback(err, res);
    });
  };

  multihashing.digest(msg, HASH_ALGORITHM, function (err, digest) {
    if (err) return done(err);
    try {
      var sig = secp256k1.sign(digest, key);
      var sigDER = secp256k1.signatureExport(sig.signature);
      return done(null, sigDER);
    } catch (err) {
      done(err);
    }
  });
};

exports.hashAndVerify = function (key, sig, msg, callback) {
  var done = function done(err, res) {
    return setImmediate(function () {
      callback(err, res);
    });
  };

  multihashing.digest(msg, HASH_ALGORITHM, function (err, digest) {
    if (err) return done(err);
    try {
      sig = secp256k1.signatureImport(sig);
      var valid = secp256k1.verify(digest, sig, key);
      return done(null, valid);
    } catch (err) {
      done(err);
    }
  });
};

exports.compressPublicKey = function compressPublicKey(key) {
  if (!secp256k1.publicKeyVerify(key)) {
    throw new Error('Invalid public key');
  }
  return secp256k1.publicKeyConvert(key, true);
};

exports.decompressPublicKey = function decompressPublicKey(key) {
  return secp256k1.publicKeyConvert(key, false);
};

exports.validatePrivateKey = function validatePrivateKey(key) {
  if (!secp256k1.privateKeyVerify(key)) {
    throw new Error('Invalid private key');
  }
};

exports.validatePublicKey = function validatePublicKey(key) {
  if (!secp256k1.publicKeyVerify(key)) {
    throw new Error('Invalid public key');
  }
};

exports.computePublicKey = function computePublicKey(privateKey) {
  exports.validatePrivateKey(privateKey);
  return secp256k1.publicKeyCreate(privateKey);
};