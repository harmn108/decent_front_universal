'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var multihashing = require('multihashing-async');
var protobuf = require('protocol-buffers');
var Buffer = require('safe-buffer').Buffer;

var crypto = require('../crypto').ed25519;
var pbm = protobuf(require('../crypto.proto'));

var Ed25519PublicKey = function () {
  function Ed25519PublicKey(key) {
    _classCallCheck(this, Ed25519PublicKey);

    this._key = ensureKey(key, crypto.publicKeyLength);
  }

  _createClass(Ed25519PublicKey, [{
    key: 'verify',
    value: function verify(data, sig, callback) {
      ensure(callback);
      crypto.hashAndVerify(this._key, sig, data, callback);
    }
  }, {
    key: 'marshal',
    value: function marshal() {
      return Buffer.from(this._key);
    }
  }, {
    key: 'equals',
    value: function equals(key) {
      return this.bytes.equals(key.bytes);
    }
  }, {
    key: 'hash',
    value: function hash(callback) {
      ensure(callback);
      multihashing(this.bytes, 'sha2-256', callback);
    }
  }, {
    key: 'bytes',
    get: function get() {
      return pbm.PublicKey.encode({
        Type: pbm.KeyType.Ed25519,
        Data: this.marshal()
      });
    }
  }]);

  return Ed25519PublicKey;
}();

var Ed25519PrivateKey = function () {
  // key       - 64 byte Uint8Array or Buffer containing private key
  // publicKey - 32 byte Uint8Array or Buffer containing public key
  function Ed25519PrivateKey(key, publicKey) {
    _classCallCheck(this, Ed25519PrivateKey);

    this._key = ensureKey(key, crypto.privateKeyLength);
    this._publicKey = ensureKey(publicKey, crypto.publicKeyLength);
  }

  _createClass(Ed25519PrivateKey, [{
    key: 'sign',
    value: function sign(message, callback) {
      ensure(callback);
      crypto.hashAndSign(this._key, message, callback);
    }
  }, {
    key: 'marshal',
    value: function marshal() {
      return Buffer.concat([Buffer.from(this._key), Buffer.from(this._publicKey)]);
    }
  }, {
    key: 'equals',
    value: function equals(key) {
      return this.bytes.equals(key.bytes);
    }
  }, {
    key: 'hash',
    value: function hash(callback) {
      ensure(callback);
      multihashing(this.bytes, 'sha2-256', callback);
    }
  }, {
    key: 'public',
    get: function get() {
      if (!this._publicKey) {
        throw new Error('public key not provided');
      }

      return new Ed25519PublicKey(this._publicKey);
    }
  }, {
    key: 'bytes',
    get: function get() {
      return pbm.PrivateKey.encode({
        Type: pbm.KeyType.Ed25519,
        Data: this.marshal()
      });
    }
  }]);

  return Ed25519PrivateKey;
}();

function unmarshalEd25519PrivateKey(bytes, callback) {
  try {
    bytes = ensureKey(bytes, crypto.privateKeyLength + crypto.publicKeyLength);
  } catch (err) {
    return callback(err);
  }
  var privateKeyBytes = bytes.slice(0, crypto.privateKeyLength);
  var publicKeyBytes = bytes.slice(crypto.privateKeyLength, bytes.length);
  callback(null, new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes));
}

function unmarshalEd25519PublicKey(bytes) {
  bytes = ensureKey(bytes, crypto.publicKeyLength);
  return new Ed25519PublicKey(bytes);
}

function generateKeyPair(_bits, cb) {
  if (cb === undefined && typeof _bits === 'function') {
    cb = _bits;
  }

  crypto.generateKey(function (err, keys) {
    if (err) {
      return cb(err);
    }
    var privkey = void 0;
    try {
      privkey = new Ed25519PrivateKey(keys.secretKey, keys.publicKey);
    } catch (err) {
      cb(err);
      return;
    }

    cb(null, privkey);
  });
}

function generateKeyPairFromSeed(seed, _bits, cb) {
  if (cb === undefined && typeof _bits === 'function') {
    cb = _bits;
  }

  crypto.generateKeyFromSeed(seed, function (err, keys) {
    if (err) {
      return cb(err);
    }
    var privkey = void 0;
    try {
      privkey = new Ed25519PrivateKey(keys.secretKey, keys.publicKey);
    } catch (err) {
      cb(err);
      return;
    }

    cb(null, privkey);
  });
}

function ensure(cb) {
  if (typeof cb !== 'function') {
    throw new Error('callback is required');
  }
}

function ensureKey(key, length) {
  if (Buffer.isBuffer(key)) {
    key = new Uint8Array(key);
  }
  if (!(key instanceof Uint8Array) || key.length !== length) {
    throw new Error('Key must be a Uint8Array or Buffer of length ' + length);
  }
  return key;
}

module.exports = {
  Ed25519PublicKey: Ed25519PublicKey,
  Ed25519PrivateKey: Ed25519PrivateKey,
  unmarshalEd25519PrivateKey: unmarshalEd25519PrivateKey,
  unmarshalEd25519PublicKey: unmarshalEd25519PublicKey,
  generateKeyPair: generateKeyPair,
  generateKeyPairFromSeed: generateKeyPairFromSeed
};