'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var multihashing = require('multihashing-async');
var protobuf = require('protocol-buffers');

var crypto = require('../crypto').rsa;
var pbm = protobuf(require('../crypto.proto'));

var RsaPublicKey = function () {
  function RsaPublicKey(key) {
    _classCallCheck(this, RsaPublicKey);

    this._key = key;
  }

  _createClass(RsaPublicKey, [{
    key: 'verify',
    value: function verify(data, sig, callback) {
      ensure(callback);
      crypto.hashAndVerify(this._key, sig, data, callback);
    }
  }, {
    key: 'marshal',
    value: function marshal() {
      return crypto.utils.jwkToPkix(this._key);
    }
  }, {
    key: 'encrypt',
    value: function encrypt(bytes) {
      return this._key.encrypt(bytes, 'RSAES-PKCS1-V1_5');
    }
  }, {
    key: 'equals',
    value: function equals(key) {
      return this.bytes.equals(key.bytes);
    }
  }, {
    key: 'hash',
    value: function hash(callback) {
      ensure(callback);
      multihashing(this.bytes, 'sha2-256', callback);
    }
  }, {
    key: 'bytes',
    get: function get() {
      return pbm.PublicKey.encode({
        Type: pbm.KeyType.RSA,
        Data: this.marshal()
      });
    }
  }]);

  return RsaPublicKey;
}();

var RsaPrivateKey = function () {
  // key       - Object of the jwk format
  // publicKey - Buffer of the spki format
  function RsaPrivateKey(key, publicKey) {
    _classCallCheck(this, RsaPrivateKey);

    this._key = key;
    this._publicKey = publicKey;
  }

  _createClass(RsaPrivateKey, [{
    key: 'genSecret',
    value: function genSecret() {
      return crypto.getRandomValues(new Uint8Array(16));
    }
  }, {
    key: 'sign',
    value: function sign(message, callback) {
      ensure(callback);
      crypto.hashAndSign(this._key, message, callback);
    }
  }, {
    key: 'decrypt',
    value: function decrypt(msg, callback) {
      crypto.decrypt(this._key, msg, callback);
    }
  }, {
    key: 'marshal',
    value: function marshal() {
      return crypto.utils.jwkToPkcs1(this._key);
    }
  }, {
    key: 'equals',
    value: function equals(key) {
      return this.bytes.equals(key.bytes);
    }
  }, {
    key: 'hash',
    value: function hash(callback) {
      ensure(callback);
      multihashing(this.bytes, 'sha2-256', callback);
    }
  }, {
    key: 'public',
    get: function get() {
      if (!this._publicKey) {
        throw new Error('public key not provided');
      }

      return new RsaPublicKey(this._publicKey);
    }
  }, {
    key: 'bytes',
    get: function get() {
      return pbm.PrivateKey.encode({
        Type: pbm.KeyType.RSA,
        Data: this.marshal()
      });
    }
  }]);

  return RsaPrivateKey;
}();

function unmarshalRsaPrivateKey(bytes, callback) {
  var jwk = crypto.utils.pkcs1ToJwk(bytes);
  crypto.unmarshalPrivateKey(jwk, function (err, keys) {
    if (err) {
      return callback(err);
    }

    callback(null, new RsaPrivateKey(keys.privateKey, keys.publicKey));
  });
}

function unmarshalRsaPublicKey(bytes) {
  var jwk = crypto.utils.pkixToJwk(bytes);

  return new RsaPublicKey(jwk);
}

function generateKeyPair(bits, cb) {
  crypto.generateKey(bits, function (err, keys) {
    if (err) {
      return cb(err);
    }

    cb(null, new RsaPrivateKey(keys.privateKey, keys.publicKey));
  });
}

function ensure(cb) {
  if (typeof cb !== 'function') {
    throw new Error('callback is required');
  }
}

module.exports = {
  RsaPublicKey: RsaPublicKey,
  RsaPrivateKey: RsaPrivateKey,
  unmarshalRsaPublicKey: unmarshalRsaPublicKey,
  unmarshalRsaPrivateKey: unmarshalRsaPrivateKey,
  generateKeyPair: generateKeyPair
};