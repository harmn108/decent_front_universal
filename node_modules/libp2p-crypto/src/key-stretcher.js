'use strict';

var crypto = require('./crypto');
var whilst = require('async/whilst');
var Buffer = require('safe-buffer').Buffer;

var cipherMap = {
  'AES-128': {
    ivSize: 16,
    keySize: 16
  },
  'AES-256': {
    ivSize: 16,
    keySize: 32
  },
  Blowfish: {
    ivSize: 8,
    cipherKeySize: 32
  }

  // Generates a set of keys for each party by stretching the shared key.
  // (myIV, theirIV, myCipherKey, theirCipherKey, myMACKey, theirMACKey)
};module.exports = function (cipherType, hash, secret, callback) {
  var cipher = cipherMap[cipherType];

  if (!cipher) {
    return callback(new Error('unkown cipherType passed'));
  }

  if (!hash) {
    return callback(new Error('unkown hashType passed'));
  }

  var cipherKeySize = cipher.keySize;
  var ivSize = cipher.ivSize;
  var hmacKeySize = 20;
  var seed = Buffer.from('key expansion');
  var resultLength = 2 * (ivSize + cipherKeySize + hmacKeySize);

  crypto.hmac.create(hash, secret, function (err, m) {
    if (err) {
      return callback(err);
    }

    m.digest(seed, function (err, a) {
      if (err) {
        return callback(err);
      }

      var result = [];
      var j = 0;

      whilst(function () {
        return j < resultLength;
      }, stretch, finish);

      function stretch(cb) {
        m.digest(Buffer.concat([a, seed]), function (err, b) {
          if (err) {
            return cb(err);
          }

          var todo = b.length;

          if (j + todo > resultLength) {
            todo = resultLength - j;
          }

          result.push(b);

          j += todo;

          m.digest(a, function (err, _a) {
            if (err) {
              return cb(err);
            }
            a = _a;
            cb();
          });
        });
      }

      function finish(err) {
        if (err) {
          return callback(err);
        }

        var half = resultLength / 2;
        var resultBuffer = Buffer.concat(result);
        var r1 = resultBuffer.slice(0, half);
        var r2 = resultBuffer.slice(half, resultLength);

        var createKey = function createKey(res) {
          return {
            iv: res.slice(0, ivSize),
            cipherKey: res.slice(ivSize, ivSize + cipherKeySize),
            macKey: res.slice(ivSize + cipherKeySize)
          };
        };

        callback(null, {
          k1: createKey(r1),
          k2: createKey(r2)
        });
      }
    });
  });
};