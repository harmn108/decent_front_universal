'use strict';

// Node.js land
// First we look if node-webrypto-ossl is available
// otherwise we fall back to using keypair + node core

var webcrypto = void 0;
try {
  webcrypto = require('node-webcrypto-ossl');
} catch (err) {
  // not available, use the code below
}

if (webcrypto && !process.env.NO_WEBCRYPTO) {
  module.exports = require('./rsa-browser');
} else {
  var crypto = require('crypto');
  var keypair = require('keypair');
  var setImmediate = require('async/setImmediate');
  var pemToJwk = require('pem-jwk').pem2jwk;
  var jwkToPem = require('pem-jwk').jwk2pem;

  exports.utils = require('./rsa-utils');

  exports.generateKey = function (bits, callback) {
    var done = function done(err, res) {
      return setImmediate(function () {
        callback(err, res);
      });
    };

    var key = void 0;
    try {
      key = keypair({
        bits: bits
      });
    } catch (err) {
      done(err);
      return;
    }

    done(null, {
      privateKey: pemToJwk(key.private),
      publicKey: pemToJwk(key.public)
    });
  };

  // Takes a jwk key
  exports.unmarshalPrivateKey = function (key, callback) {
    callback(null, {
      privateKey: key,
      publicKey: {
        kty: key.kty,
        n: key.n,
        e: key.e
      }
    });
  };

  exports.getRandomValues = function (arr) {
    return crypto.randomBytes(arr.length);
  };

  exports.hashAndSign = function (key, msg, callback) {
    var sign = crypto.createSign('RSA-SHA256');

    sign.update(msg);
    setImmediate(function () {
      callback(null, sign.sign(jwkToPem(key)));
    });
  };

  exports.hashAndVerify = function (key, sig, msg, callback) {
    var verify = crypto.createVerify('RSA-SHA256');

    verify.update(msg);

    setImmediate(function () {
      callback(null, verify.verify(jwkToPem(key), sig));
    });
  };
}