'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ensureMultiaddr = require('./utils').ensureMultiaddr;
var uniqBy = require('lodash.uniqby');

// Because JavaScript doesn't let you overload the compare in Set()..

var MultiaddrSet = function () {
  function MultiaddrSet(multiaddrs) {
    _classCallCheck(this, MultiaddrSet);

    this._multiaddrs = multiaddrs || [];
    this._observedMultiaddrs = [];
  }

  _createClass(MultiaddrSet, [{
    key: 'add',
    value: function add(ma) {
      ma = ensureMultiaddr(ma);

      if (!this.has(ma)) {
        this._multiaddrs.push(ma);
      }
    }

    // addSafe - prevent multiaddr explosionâ„¢
    // Multiaddr explosion is when you dial to a bunch of nodes and every node
    // gives you a different observed address and you start storing them all to
    // share with other peers. This seems like a good idea until you realize that
    // most of those addresses are unique to the subnet that peer is in and so,
    // they are completely worthless for all the other peers. This method is
    // exclusively used by identify.

  }, {
    key: 'addSafe',
    value: function addSafe(ma) {
      var _this = this;

      ma = ensureMultiaddr(ma);

      var check = this._observedMultiaddrs.some(function (m, i) {
        if (m.equals(ma)) {
          _this.add(ma);
          _this._observedMultiaddrs.splice(i, 1);
          return true;
        }
      });
      if (!check) {
        this._observedMultiaddrs.push(ma);
      }
    }
  }, {
    key: 'toArray',
    value: function toArray() {
      return this._multiaddrs.slice();
    }
  }, {
    key: 'forEach',
    value: function forEach(fn) {
      return this._multiaddrs.forEach(fn);
    }
  }, {
    key: 'has',
    value: function has(ma) {
      ma = ensureMultiaddr(ma);
      return this._multiaddrs.some(function (m) {
        return m.equals(ma);
      });
    }
  }, {
    key: 'delete',
    value: function _delete(ma) {
      var _this2 = this;

      ma = ensureMultiaddr(ma);

      this._multiaddrs.some(function (m, i) {
        if (m.equals(ma)) {
          _this2._multiaddrs.splice(i, 1);
          return true;
        }
      });
    }

    // replaces selected existing multiaddrs with new ones

  }, {
    key: 'replace',
    value: function replace(existing, fresh) {
      var _this3 = this;

      if (!Array.isArray(existing)) {
        existing = [existing];
      }
      if (!Array.isArray(fresh)) {
        fresh = [fresh];
      }
      existing.forEach(function (m) {
        return _this3.delete(m);
      });
      fresh.forEach(function (m) {
        return _this3.add(m);
      });
    }
  }, {
    key: 'clear',
    value: function clear() {
      this._multiaddrs = [];
    }

    // this only really helps make ip6 and ip4 multiaddrs distinct if they are
    // different
    // TODO this is not an ideal solution, probably this code should just be
    // in libp2p-tcp

  }, {
    key: 'distinct',
    value: function distinct() {
      return uniqBy(this._multiaddrs, function (ma) {
        return [ma.toOptions().port, ma.toOptions().transport].join();
      });
    }
  }, {
    key: 'size',
    get: function get() {
      return this._multiaddrs.length;
    }
  }]);

  return MultiaddrSet;
}();

module.exports = MultiaddrSet;